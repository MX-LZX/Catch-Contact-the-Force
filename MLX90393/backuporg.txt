#include <Wire.h>
#include "Adafruit_MLX90393.h"

#define SDA_PIN       16
#define SCL_PIN       17
#define SERIAL_BAUD   115200

constexpr uint8_t SENSOR_ADDRS[4] = { 0x0C, 0x0D, 0x0E, 0x0F };
constexpr uint32_t SAMPLE_PERIOD_US = 25000UL;

// 手册典型系数（把温度原始计数换算为摄氏度）
constexpr float MLX_T25_LSB   = 46244.0f;   // 25°C 对应典型计数
constexpr float MLX_LSB_PER_C = 45.2f;      // LSB / °C

Adafruit_MLX90393 sensors[4];
uint32_t next_sample_us;

float offset_sum[4][3] = {0};
int offset_frame_count = 0;
bool offset_ready = false;
float offset[4][3] = {0};

// 温度原始计数缓存（轮询更新）
int16_t temp_raw[4] = {0};
uint8_t temp_idx = 0;  // 本帧读取哪一个传感器的温度

// --------- 串口命令处理 ---------
String cmd_buf;

static inline float rawToCelsius(uint16_t raw_u16) {
  // 采用典型系数换算成摄氏度
  return (raw_u16 - MLX_T25_LSB) / MLX_LSB_PER_C + 25.0f;
}

void handleSerialCommand() {
  while (Serial.available()) {
    char c = (char)Serial.read();
    if (c == '\r' || c == '\n') {
      cmd_buf.trim();
      if (cmd_buf.length() > 0) {
        if (cmd_buf.equalsIgnoreCase("temp")) {
          // 同步读取4路温度并打印摄氏度
          float tC[4] = {0};
          for (int i = 0; i < 4; ++i) {
            // 逐路读温度（独立于轮询缓存，确保使用无符号做换算）
            uint16_t tr_u16 = 0;
            // 这里利用库里已有温度读取函数（如你已按前面建议在库中加入 readTemperatureRaw(uint16_t*)）
            // 如果你的库还是 int16_t 版本，也可以读取到 int16 然后按位重组为 uint16_t
            int16_t tr_signed = 0;
            bool ok = sensors[i].readTemperatureRaw(&tr_signed);
            if (ok) {
              tr_u16 = (uint16_t)((uint16_t)((uint8_t)((tr_signed >> 8) & 0xFF)) << 8 |
                                  (uint16_t)((uint8_t)(tr_signed & 0xFF)));
              tC[i] = rawToCelsius(tr_u16);
            } else {
              // 读失败则沿用最近一次轮询缓存的原始值（同样转成无符号再换算）
              uint16_t cached_u16 = (uint16_t)((uint16_t)((uint8_t)((temp_raw[i] >> 8) & 0xFF)) << 8 |
                                               (uint16_t)((uint8_t)(temp_raw[i] & 0xFF)));
              tC[i] = rawToCelsius(cached_u16);
            }
          }
          // 打印一行摄氏度温度
          char tbuf[128];
          int tn = snprintf(tbuf, sizeof(tbuf),
                            "TEMP_C: %.2f,%.2f,%.2f,%.2f\n",
                            tC[0], tC[1], tC[2], tC[3]);
          Serial.write(tbuf, tn);
        }
      }
      cmd_buf = ""; // 清空
    } else {
      // 累积字符（避免过长）
      if (cmd_buf.length() < 64) cmd_buf += c;
    }
  }
}

// --------------------------------

void setup() {
  Serial.begin(SERIAL_BAUD);
  while (!Serial);

  Wire.setSDA(SDA_PIN);
  Wire.setSCL(SCL_PIN);
  Wire.begin();
  Wire.setClock(1000000);

  for (int i = 0; i < 4; ++i) {
    if (!sensors[i].begin_I2C(SENSOR_ADDRS[i], &Wire)) {
      Serial.print("Sensor "); Serial.print(i);
      Serial.println(" init failed!");
      while (1);
    }
    sensors[i].setResolution(MLX90393_X, MLX90393_RES_16);
    sensors[i].setResolution(MLX90393_Y, MLX90393_RES_16);
    sensors[i].setResolution(MLX90393_Z, MLX90393_RES_16);
    sensors[i].setFilter(MLX90393_FILTER_3);
    sensors[i].setOversampling(MLX90393_OSR_0);
    sensors[i].setGain(MLX90393_GAIN_1X);
  }

  for (int i = 0; i < 4; ++i) {
    sensors[i].startSingleMeasurement();
  }
  next_sample_us = micros() + SAMPLE_PERIOD_US;
}

void loop() {
  // 先处理串口命令（不阻塞）
  handleSerialCommand();

  uint32_t now = micros();
  if ((int32_t)(now - next_sample_us) < 0) return;

  float x[4], y[4], z[4];
  for (int i = 0; i < 4; ++i) {
    sensors[i].readMeasurement(&x[i], &y[i], &z[i]);
  }

  // === 先读温度（避免和接下来新的磁场测量冲突）===
  {
    int16_t tr_signed = 0;
    bool ok = sensors[temp_idx].readTemperatureRaw(&tr_signed);
    if (ok) {
      temp_raw[temp_idx] = tr_signed;
    } else {
      // 可选：重试一次（有时总线/状态机会抖）
      if (sensors[temp_idx].readTemperatureRaw(&tr_signed)) {
        temp_raw[temp_idx] = tr_signed;
      }
      // 也可以在这里 Serial.println("TEMP READ FAIL on #..."); 便于排查
    }
    temp_idx = (temp_idx + 1) % 4;
  }

  // === 再启动下一帧的磁场单次测量 ===
  for (int i = 0; i < 4; ++i) {
    sensors[i].startSingleMeasurement();
  }

  next_sample_us += SAMPLE_PERIOD_US;

  // 串口输出：12 个磁场 + 4 个温度原始计数
  char buf[196];
  int n = snprintf(buf, sizeof(buf),
    "%.2f,%.2f,%.2f,%.2f,%.2f,%.2f,%.2f,%.2f,%.2f,%.2f,%.2f,%.2f\n",
    x[0], y[0], z[0],
    x[1], y[1], z[1],
    x[2], y[2], z[2],
    x[3], y[3], z[3]
  );
  Serial.write(buf, n);
}
