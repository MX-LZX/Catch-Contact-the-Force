#include <Wire.h>
#include "Adafruit_MLX90393.h"

#define SDA_PIN       16
#define SCL_PIN       17
#define SERIAL_BAUD   115200

constexpr uint8_t SENSOR_ADDRS[4] = { 0x0C, 0x0D, 0x0E, 0x0F };
constexpr uint32_t SAMPLE_PERIOD_US = 25000UL;
constexpr float EMA_ALPHA = 0.2f;  // EMA 系数

Adafruit_MLX90393 sensors[4];
uint32_t next_sample_us;

float offset_sum[4][3] = {0};
int offset_frame_count = 0;
bool offset_ready = false;
float offset[4][3] = {0};

// EMA 滤波缓存
float ema_filtered[4][3] = {0};
bool ema_initialized = false;

void setup() {
  Serial.begin(SERIAL_BAUD);
  while (!Serial);

  Wire.setSDA(SDA_PIN);
  Wire.setSCL(SCL_PIN);
  Wire.begin();
  Wire.setClock(1000000);

  for (int i = 0; i < 4; ++i) {
    if (!sensors[i].begin_I2C(SENSOR_ADDRS[i], &Wire)) {
      Serial.print("Sensor "); Serial.print(i);
      Serial.println(" init failed!");
      while (1);
    }
    sensors[i].setResolution(MLX90393_X, MLX90393_RES_16);
    sensors[i].setResolution(MLX90393_Y, MLX90393_RES_16);
    sensors[i].setResolution(MLX90393_Z, MLX90393_RES_16);
    sensors[i].setFilter(MLX90393_FILTER_3);
    sensors[i].setOversampling(MLX90393_OSR_0);
    sensors[i].setGain(MLX90393_GAIN_1X);
  }

  for (int i = 0; i < 4; ++i) {
    sensors[i].startSingleMeasurement();
  }
  next_sample_us = micros() + SAMPLE_PERIOD_US;
}

void loop() {
  uint32_t now = micros();
  if ((int32_t)(now - next_sample_us) < 0) return;

  float x[4], y[4], z[4];
  for (int i = 0; i < 4; ++i) {
    sensors[i].readMeasurement(&x[i], &y[i], &z[i]);
  }

  for (int i = 0; i < 4; ++i) {
    sensors[i].startSingleMeasurement();
  }
  next_sample_us += SAMPLE_PERIOD_US;

  static int frame_id = 0;
  frame_id++;

  if (!offset_ready && frame_id >= 5 && frame_id <= 10) {
    for (int i = 0; i < 4; ++i) {
      offset_sum[i][0] += x[i];
      offset_sum[i][1] += y[i];
      offset_sum[i][2] += z[i];
    }
    offset_frame_count++;

    if (frame_id == 10) {
      for (int i = 0; i < 4; ++i) {
        offset[i][0] = offset_sum[i][0] / offset_frame_count;
        offset[i][1] = offset_sum[i][1] / offset_frame_count;
        offset[i][2] = offset_sum[i][2] / offset_frame_count;
      }
      offset_ready = true;
    }
    return;
  }

  if (offset_ready) {
    for (int i = 0; i < 4; ++i) {
      x[i] -= offset[i][0];
      y[i] -= offset[i][1];
      z[i] -= offset[i][2];
    }
  }

  // EMA 滤波
  for (int i = 0; i < 4; ++i) { 
    if (!ema_initialized) {
      ema_filtered[i][0] = x[i];
      ema_filtered[i][1] = y[i];
      ema_filtered[i][2] = z[i];
    } else {
      ema_filtered[i][0] = EMA_ALPHA * x[i] + (1 - EMA_ALPHA) * ema_filtered[i][0];
      ema_filtered[i][1] = EMA_ALPHA * y[i] + (1 - EMA_ALPHA) * ema_filtered[i][1];
      ema_filtered[i][2] = EMA_ALPHA * z[i] + (1 - EMA_ALPHA) * ema_filtered[i][2];
    }
  }
  ema_initialized = true;

  // 串口输出
  char buf[128];
  int n = snprintf(buf, sizeof(buf),
    "%.2f,%.2f,%.2f,%.2f,%.2f,%.2f,%.2f,%.2f,%.2f,%.2f,%.2f,%.2f\n",
    ema_filtered[0][0], ema_filtered[0][1], ema_filtered[0][2],
    ema_filtered[1][0], ema_filtered[1][1], ema_filtered[1][2],
    ema_filtered[2][0], ema_filtered[2][1], ema_filtered[2][2],
    ema_filtered[3][0], ema_filtered[3][1], ema_filtered[3][2]);
  Serial.write(buf, n);
}